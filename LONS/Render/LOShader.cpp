/* LONS使用的片段着色器 */
#include "LOShader.h"
#include <SDL.h>
#include <vector>

//std::vector<std::string> shaderCache;
extern std::string G_RenderName;  //渲染器使用的驱动名称

//适用于GLES2的黑白效果shader
char GLES2_Fragment_TextureGray[] = \
"uniform sampler2D u_texture;\n"                                \
"varying mediump vec4 v_color;\n"                               \
"varying SDL_TEXCOORD_PRECISION vec2 v_texCoord;\n"             \
"\n"                                                            \
"void main()\n"                                                 \
"{\n"                                                           \
"    mediump vec4 abgr = texture2D(u_texture, v_texCoord);\n"   \
"    gl_FragColor = vec4((abgr.b+abgr.g+abgr.r)/3.0);\n"        \
"    gl_FragColor.a = abgr.a;\n"                                \
"    gl_FragColor *= v_color;\n"                                \
"}\n"                                                           \
;

//适用于opengl的黑白效果shader
char GL_Fragment_TextureGray[] = \
"varying vec4 v_color;\n"
"varying vec2 v_texCoord;\n"
"uniform sampler2D tex0;\n"
"\n"
"void main()\n"
"{\n"
"    gl_FragColor = texture2D(tex0, v_texCoord) * v_color;\n"
"    gl_FragColor.r = (gl_FragColor.r+gl_FragColor.g+gl_FragColor.b)/3.0;\n"
"    gl_FragColor.g = gl_FragColor.r;\n"
"    gl_FragColor.b = gl_FragColor.r;\n"
"}"
;

////适用于d3d9的黑白效果shader
//Texture2D theTextureY : register(t0);
//SamplerState theSampler = sampler_state
//{
//	addressU = Clamp;
//	addressV = Clamp;
//	mipfilter = NONE;
//	minfilter = LINEAR;
//	magfilter = LINEAR;
//};
//
//struct PixelShaderInput
//{
//	float4 pos : SV_POSITION;
//	float2 tex : TEXCOORD0;
//	float4 color : COLOR0;
//};
//
//float4 main(PixelShaderInput input) : SV_TARGET
//{
//	float4 Output;
//	float4 yuv;
//	yuv = tex2D(theSampler, input.tex);
//	Output.r = (yuv.r + yuv.g + yuv.b) / 3.0;
//	Output.g = Output.r;
//	Output.b = Output.r;
//	Output.a = yuv.a;
//	return Output * input.color;
//}
unsigned char D3D_Fragment_TextureGray[] = 
{
	0x00, 0x02, 0xFF, 0xFF, 0xFE, 0xFF, 0x20, 0x00, 0x43, 0x54, 0x41, 0x42, 0x1C, 0x00, 0x00, 0x00,
	0x53, 0x00, 0x00, 0x00, 0x00, 0x02, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x4C, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x68, 0x65, 0x53,
	0x61, 0x6D, 0x70, 0x6C, 0x65, 0x72, 0x00, 0xAB, 0x04, 0x00, 0x0C, 0x00, 0x01, 0x00, 0x01, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x73, 0x5F, 0x32, 0x5F, 0x30, 0x00, 0x4D,
	0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4C, 0x53,
	0x4C, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65,
	0x72, 0x20, 0x31, 0x30, 0x2E, 0x31, 0x00, 0xAB, 0x51, 0x00, 0x00, 0x05, 0x00, 0x00, 0x0F, 0xA0,
	0xAB, 0xAA, 0xAA, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1F, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x03, 0xB0, 0x1F, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x0F, 0x90, 0x1F, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x90,
	0x00, 0x08, 0x0F, 0xA0, 0x42, 0x00, 0x00, 0x03, 0x00, 0x00, 0x0F, 0x80, 0x00, 0x00, 0xE4, 0xB0,
	0x00, 0x08, 0xE4, 0xA0, 0x02, 0x00, 0x00, 0x03, 0x01, 0x00, 0x08, 0x80, 0x00, 0x00, 0x55, 0x80,
	0x00, 0x00, 0x00, 0x80, 0x02, 0x00, 0x00, 0x03, 0x01, 0x00, 0x01, 0x80, 0x00, 0x00, 0xAA, 0x80,
	0x01, 0x00, 0xFF, 0x80, 0x05, 0x00, 0x00, 0x03, 0x00, 0x00, 0x07, 0x80, 0x01, 0x00, 0x00, 0x80,
	0x00, 0x00, 0x00, 0xA0, 0x05, 0x00, 0x00, 0x03, 0x00, 0x00, 0x0F, 0x80, 0x00, 0x00, 0xE4, 0x80,
	0x00, 0x00, 0xE4, 0x90, 0x01, 0x00, 0x00, 0x02, 0x00, 0x08, 0x0F, 0x80, 0x00, 0x00, 0xE4, 0x80,
	0xFF, 0xFF, 0x00, 0x00,
};

char* GLES2_Array[] = { nullptr, GLES2_Fragment_TextureGray };
char* GL_Array[] = { nullptr, GL_Fragment_TextureGray };

//前4字节有特殊用途，
//[0]为shader id，
//[1]操作要求，
//[2]是否已经编译失败，0为还没有编译，1为编译失败，其他为编译成功
//[3]SDL2内部使用，注意只有修改过的SDL2才支持，0为没有被使用，1为被使用
std::string CreateLonsShader(int vtype) {
	if (vtype > 0) {
		char tmp[] = "\0\0\0\0";
		tmp[0] = vtype & 0xff;
		std::string s(tmp, 4);

		if (G_RenderName == "opengles2") s.append(GLES2_Array[vtype]);
		else if(G_RenderName == "opengl") s.append(GL_Array[vtype]);
		else if (G_RenderName == "direct3d") {
			if(vtype == 1) s.append((char*)D3D_Fragment_TextureGray, sizeof(D3D_Fragment_TextureGray));
		}
		//printf(s.c_str() + 4);
        s.append("\0\0");

		return s;
	}
	return std::string();
}
